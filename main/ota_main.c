#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_event.h"
#include "nvs_flash.h"
#include "esp_wifi.h"
#include "esp_http_client.h"
#include "esp_https_ota.h"
#include "esp_ota_ops.h"
#include "esp_netif.h"
#include "cJSON.h"
#include "ota_config.h"

static const char *TAG = "ota_project";

/* Symbols generated by EMBED_TXTFILES for cert: certs/server_cert.pem */
extern const char _binary_certs_server_cert_pem_start[] asm("_binary_certs_server_cert_pem_start");
extern const char _binary_certs_server_cert_pem_end[]   asm("_binary_certs_server_cert_pem_end");

static const char *get_embedded_ca_cert(void)
{
    const char *start = _binary_certs_server_cert_pem_start;
    const char *end   = _binary_certs_server_cert_pem_end;
    if (!start || start == end) return NULL;
    size_t len = (size_t)(end - start);
    if (len < 16) return NULL; // obviously too small to be a valid PEM
    return start;
}

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        ESP_LOGW(TAG, "WiFi disconnected, reconnecting...");
        esp_wifi_connect();
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "Got IP: %s", ip4addr_ntoa(&event->ip_info.ip));
    }
}

static void wifi_init_sta(void)
{
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    esp_event_handler_instance_t any_id, got_ip;
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL, &any_id));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL, &got_ip));

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASS,
            .threshold.authmode = WIFI_AUTH_WPA2_PSK,
        },
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());
}

/* Robust HTTP GET that supports unknown/large content lengths.
   Caller must free() the returned buffer. */
static char *http_get_string(const char *url)
{
    esp_http_client_config_t config = {
        .url = url,
        .timeout_ms = 10000,
    };
    esp_http_client_handle_t client = esp_http_client_init(&config);
    if (!client) {
        ESP_LOGE(TAG, "http_client_init failed");
        return NULL;
    }

    esp_err_t err = esp_http_client_open(client, 0);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "http_client_open failed: %s", esp_err_to_name(err));
        esp_http_client_cleanup(client);
        return NULL;
    }

    const size_t CHUNK_SIZE = 1024;
    size_t buf_cap = CHUNK_SIZE;
    size_t total = 0;
    char *buf = malloc(buf_cap + 1);
    if (!buf) {
        ESP_LOGE(TAG, "malloc failed");
        esp_http_client_cleanup(client);
        return NULL;
    }

    while (1) {
        int r = esp_http_client_read(client, buf + total, CHUNK_SIZE);
        if (r < 0) {
            ESP_LOGE(TAG, "http_client_read error: %d", r);
            free(buf);
            esp_http_client_cleanup(client);
            return NULL;
        }
        if (r == 0) break; // EOF
        total += r;
        if (total + 1 >= buf_cap) {
            buf_cap *= 2;
            char *tmp = realloc(buf, buf_cap + 1);
            if (!tmp) {
                ESP_LOGE(TAG, "realloc failed");
                free(buf);
                esp_http_client_cleanup(client);
                return NULL;
            }
            buf = tmp;
        }
    }

    buf[total] = '\0';
    esp_http_client_cleanup(client);
    return buf;
}

/* Simple semantic version compare */
static int version_cmp(const char *a, const char *b)
{
    if (!a || !b) return 0;
    while (*a || *b) {
        int anum = 0, bnum = 0;
        while (*a && *a != '.') { anum = anum*10 + (*a - '0'); a++; }
        while (*b && *b != '.') { bnum = bnum*10 + (*b - '0'); b++; }
        if (anum < bnum) return -1;
        if (anum > bnum) return 1;
        if (*a == '.') a++;
        if (*b == '.') b++;
    }
    return 0;
}

static void ota_task(void *pvParameter)
{
    ESP_LOGI(TAG, "OTA task started");

    char *manifest = http_get_string(MANIFEST_URL);
    if (!manifest) {
        ESP_LOGE(TAG, "Failed to fetch manifest");
        vTaskDelete(NULL);
        return;
    }

    cJSON *root = cJSON_Parse(manifest);
    free(manifest);
    if (!root) {
        ESP_LOGE(TAG, "Manifest JSON parse error");
        vTaskDelete(NULL);
        return;
    }

    cJSON *jver = cJSON_GetObjectItem(root, "version");
    cJSON *jurl = cJSON_GetObjectItem(root, "url");
    cJSON *jsha = cJSON_GetObjectItem(root, "sha256"); // optional

    if (!cJSON_IsString(jver) || !cJSON_IsString(jurl)) {
        ESP_LOGE(TAG, "Manifest missing version/url");
        cJSON_Delete(root);
        vTaskDelete(NULL);
        return;
    }

    const char *new_version = jver->valuestring;
    const char *fw_url = jurl->valuestring;
    ESP_LOGI(TAG, "Current: %s, Remote: %s", CURRENT_FW_VERSION, new_version);

    if (version_cmp(CURRENT_FW_VERSION, new_version) >= 0) {
        ESP_LOGI(TAG, "No update required");
        cJSON_Delete(root);
        vTaskDelete(NULL);
        return;
    }

    esp_http_client_config_t ota_config = {
        .url = fw_url,
        .timeout_ms = 20000,
    };

    const char *embedded_ca = get_embedded_ca_cert();
    if (embedded_ca) {
        ota_config.cert_pem = embedded_ca;
        ESP_LOGI(TAG, "Using embedded CA cert");
    } else {
        ESP_LOGW(TAG, "No embedded CA cert found; using system CA (not recommended)");
        ota_config.cert_pem = NULL;
    }

    ESP_LOGI(TAG, "Starting HTTPS OTA from %s", fw_url);
    esp_err_t ret = esp_https_ota(&ota_config);

    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "OTA download+write succeeded. Next boot will try new image.");
        /*
         IMPORTANT:
         Do NOT call esp_ota_mark_app_valid_cancel_rollback() here.
         The new firmware (the one you are booting into) must call
         esp_ota_mark_app_valid_cancel_rollback() after it has verified
         its own initialization and health (e.g., sensors init, freeing memory,
         self-tests). Place that call in the new image's app_main after
         successful startup checks.

         Example (in the new firmware's app_main):
           if (startup_checks_ok) {
               esp_ota_mark_app_valid_cancel_rollback();
           }
        */
        vTaskDelay(pdMS_TO_TICKS(200));
        esp_restart();
    } else {
        ESP_LOGE(TAG, "OTA failed: %s", esp_err_to_name(ret));
    }

    cJSON_Delete(root);
    vTaskDelete(NULL);
}

void app_main(void)
{
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    wifi_init_sta();

    /* Wait for IP assigned (simple) */
    vTaskDelay(pdMS_TO_TICKS(5000));

    xTaskCreate(&ota_task, "ota_task", OTA_TASK_STACK_SZ, NULL, OTA_TASK_PRIORITY, NULL);
}
